### 用户中断

我们这个破内核的中断借鉴 XV6, 某些地方有修改

1. `硬件自动完成`
   1. 禁中断（嵌套太麻烦了，或者至少上半部你别在来了）
   2. 切换到监管模式（内核态、管态）
   3. sepc <-pc；保存PC 指针（程序断点）
   4. Scause：Trap发生的原因

处理完成上面这一部分后CPU跳转到`stvec`寄存器存放的地址（就是赋给`PC`）。所以用户程序运行时候这个一定要初始化为`uservec`，在内核运行时为`kernelvec`。由这个地址进入下一步处理阶段。



2. `uservec`
   1. 加载内核栈（理论上内核栈应该是空的，也就是栈顶和栈底一样，可以通过`PCB`计算获取位置）
   2. 保存所有寄存器到内核栈
   3. 跳转到`usertrap`

我们直接把内核空间也放在用户的虚拟地址中，这样可以避免因为切换页表带来的开销。用户程序在链接时需使用我们的的链接脚本。

这里问题来了，我们如何知道其内核栈的地址呢？
解决方案：
- 对于所有的用户程序，当准备从内核态返回到用户态时候，也就是中断返回的时候，我们选择其 scratch 寄存器存放内核栈的地址，当中断发生的时候，就直接使用。



3. `usertrap`
   1. 实际处理中断


4. 上述依次返回

中断的流程中，会涉及到页表的切换：

1. **中断发生**的时候，由于内核空间也被映射到用户页表，内核可以直接使用用户页表，因此没有必要进行页表切换。

2. **中断返回**的时候
   1. 前后页表**一致**，即具有相同页表的线程，在切换的时候可以不用切换页表。
      - 自己中断发生，处理后返回，假如没下处理机 
      - 同一进程的若干线程（共用一副页表）
   2. 前后页表**不一致**，即发生了进程切换，此时需要切换页表

对于切换页表的代码位置，我们选择在 `usertrapret`(kernel/trap.c) 进行操作。由于此代码位于内核空间，所有进程又都共用一个该内核空间，即使发生页表切换，也能够代码顺利执行下去。

在用户态，中断发生的时候，CPU会自动跳转到 uservec，在这里会将寄存器保存在线程的内核栈中。
假如要发生进程切换，那么会有一次上下文切换 （switch context），在这里会再次保存一次寄存器。
当第一个用户程序需要运行的时候，首先要为其准备好上下文 context：
   ra: forkret
   sp: 内核栈指针，由于是模拟的内核栈，因此应该需要假装是中断过的，也就是 top - 256?

上下文完成切换后，需要退出中断。在 userret 中会再次恢复一次寄存器，并通过 sret 返回：
   sp: 用户栈指针（这个 sp 是内核栈中存放的 sp）。
   epc:返回后的 pc  

### 缺页中断的处理

对于缺页中断我们要区分待处理的任务情况是否需要睡眠，判断是否需要睡眠，我们在每个虚存段的 `fault` 函数中进程处理。
- 对于堆栈这种是不需要睡眠的，那么在 `vma_stack_fault` 函数中就简单的进行分配页面，映射页面即可。
- 对于需要睡眠的函数，比如 `vma_file_fault` ，因为此时我们是在中断环境中，这里面就不能够直接陷入睡眠去等待读页面。较好的作法是，我们将当前的进程挂起，也就是直接操作进入 cpu->out 队列,设置相关状态。此时程序就被挂起了，然后我们需要设置一个唤醒定时器。（我们选择在 `timer_create` 函数中以需要堵塞的情况加入一个内核线程，这个内核线程读完磁盘后会将原来的任务给重新加入就绪队列，至于在加入之前，这个程序需不需要放在某个特定的队列呢，我们，额，**等待考虑**），此后我们直接在原来的中断处理程序中调用 `sched` 进行重新调度即可。然后定时器被执行，执行函数读完磁盘后进行映射（需要原来进程的`mm_struct`结构），并唤醒原来程序，当后面某若干重新调度会原来程序，此时的页面已经被读入，于是可以继续运行。

对于使用定时器进行传参的处理函数，我们定义一个专门的传参结构`fault_args_struct`
其包含以下字段：
- mm_struct
- vm_ara_struct
- fault_addr

其他问题来了，用户中断返回是可以刷新页表的，但是内核中中断回来是直接走函数调用回来的，并没有个类似地有个 usertrapret。因此，当以前被映射后回来，原来的中断处理程序可能用的别的程序的内核页表。此时，对于这个进程来说，就需要切换页表了，于是，我们统一在缺页中断函数最后，刷新TLB。

另外，对于支持多线程的进程来说，如果多个线程对某个页面同时发生缺页中断。
我们规定：**一个虚存页面缺页只能有一个线程在处理缺页**，在加锁的情况下，第一个到达的线程对这个 PTE 做一个额外的标志，表示这个 PTE 正在被处理缺页中断。其他的线程如果也发生，则等到第一个线程把锁释放后，进入临界区，如果标志在，这直接作为就绪态被下处理机,也就是直接 `yield`，再醒来，再检查，（这里**不能使用！睡眠锁！**）再循环直到页面标志销毁。第一个线程把这个页面映射完成后就释放页面标志就好。我们选择 PTE 的第另外一个保留位（目前全被用了，一个 cow标志,一个这个标志）。

### 读写锁
1. 可拆解为`读锁`和`写锁`
   1. 读锁：允许多个线程同时获取
   1. 写锁：排他锁，期间只能有一个线程使用，期间其他的读写都需要堵住


1. 读优先：
   1. 读锁：如果有写锁被持有，则堵塞，否则立即获取
   1. 写锁：当前没有任何锁，获取，否则等所有锁释放后才获取


1. 写优先：
   1. 如果有写锁被持有或者写锁在等待，则堵塞，且需要所有写锁请求完成后才能获取
   1. 写锁：同上

读优先，可能造成写锁饥饿，写优先，对于吞吐大，读多的系统来说，效率相比下要低。


